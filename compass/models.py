# Copyright 2022 UW-IT, University of Washington
# SPDX-License-Identifier: Apache-2.0

from django.db import models
from simple_history.models import HistoricalRecords
from uw_person_client import UWPersonClient
from compass.dao.group import is_group_member


class AppUserManager(models.Manager):

    def upsert_appuser(self, uwnetid):
        # request the current person object for the user
        client = UWPersonClient()
        person = client.get_person_by_uwnetid(uwnetid)
        # check the AppUser table to see if they have an existing entry
        persons_netids = person.prior_uwnetids + [person.uwnetid]
        for netid in persons_netids:
            try:
                # update the AppUsers uwnetid
                user = AppUser.objects.get(uwnetid=netid)
                user.uwnetid = person.uwnetid
                user.save()
                return user
            except AppUser.DoesNotExist:
                continue
        else:
            # if no user is found, then create one
            user = AppUser(uwnetid=uwnetid)
            user.save()
            return user


class AppUser(models.Model):
    """
    Authenticated user
    """

    objects = AppUserManager()

    uwnetid = models.CharField(unique=True, max_length=50)

    # A user's Group affiliation is derived at login via GWS Groups. A GWS
    # group key is generated using the <access_id>. It is important to note
    # that UW Group memberships are managed externally from the Compass app.

    class Meta:
        indexes = [
            models.Index(fields=['uwnetid']),
        ]

    def __str__(self):
        return f"{self.uwnetid}"


class Student(models.Model):
    system_key = models.CharField(unique=True, max_length=50)
    programs = models.ManyToManyField('Program')

    class Meta:
        indexes = [
            models.Index(fields=['system_key']),
        ]

    def __str__(self):
        return self.system_key


class AccessGroupManager(models.Manager):
    def get_roles_for_user(self, request):
        """
        Return the unique roles for a user, without group context.
        """
        roles = []
        for group in super().get_queryset().all():
            for role in AccessGroup.ROLES:
                if role not in roles:
                    if is_group_member(request, group.authz_group_id):
                        roles.append(role)
        return roles


class AccessGroup(models.Model):
    """
    AccessGroups manage their Program, ContactTopic, and ContactType
    lists. AccessGroup membership is defined externally but determined for a
    AppUser via a request to the GWS at login.
    """

    ROLE_MANAGER = 'manager'
    ROLE_USER = 'user'
    ROLES = [ROLE_MANAGER, ROLE_USER]

    objects = AccessGroupManager()

    name = models.CharField(unique=True, max_length=50)
    access_group_id = models.CharField(unique=True, max_length=50)

    @property
    def authz_group_id(self, role):
        return '{}-{}'.format(self.access_group_id, role)

    def __str__(self):
        return self.name

    def has_role(self, request, role):
        return is_group_member(request, self.authz_group_id)


class Program(models.Model):
    """
    Departmental/Group Program (e.g. CAMP, TRIO, SSS, Champions, IC Eligible)
    """
    access_group = models.ForeignKey(AccessGroup, on_delete=models.CASCADE)
    name = models.CharField(unique=True, max_length=50)
    active = models.BooleanField(default=True)

    def __str__(self):
        return self.name


class Contact(models.Model):
    """
    Contact with a student
    """
    # required fields
    author = models.ForeignKey('AppUser', on_delete=models.CASCADE)
    access_group = models.ManyToManyField('AccessGroup')
    student = models.ForeignKey('Student', on_delete=models.CASCADE)
    contact_type = models.ForeignKey('ContactType', on_delete=models.CASCADE)
    date = models.DateField(auto_now=False)
    time = models.TimeField(auto_now=False)
    # optional fields
    noshow = models.BooleanField(default=False)
    notes = models.TextField(default=None, blank=True, null=True)
    actions = models.TextField(default=None, blank=True, null=True)
    contact_topics = models.ManyToManyField('ContactTopic')
    # generated by check-in queue system
    source = models.CharField(default='Compass', max_length=50)
    # contact history fields
    pub_date = models.DateTimeField(auto_now=True)
    history = HistoricalRecords(history_user_id_field='author')

    @property
    def _history_user(self):
        return self.author

    @_history_user.setter
    def _history_user(self, value):
        self.author = value

    def __str__(self):
        return f"{self.author} w/ {self.student} @ {self.date}T{self.time}"


class ContactType(models.Model):
    """
    Type of Contact
    """
    access_group = models.ForeignKey(AccessGroup, on_delete=models.CASCADE)
    name = models.CharField(unique=True, max_length=50)
    active = models.BooleanField(default=True)

    def __str__(self):
        return self.name


class ContactTopic(models.Model):
    """
    Topic discussed in a Contact
    """
    access_group = models.ForeignKey(AccessGroup, on_delete=models.CASCADE)
    name = models.CharField(unique=True, max_length=50)
    active = models.BooleanField(default=True)

    def __str__(self):
        return self.name
